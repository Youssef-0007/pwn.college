# **Revised Binary Exploitation Write-Up: PIE Bypass Challenges**

## **Introduction**
This document provides a detailed technical analysis of two **Position Independent Executable (PIE)** challenges:
1. **PIE (Easy)** - With debug information provided
2. **PIE (Hard)** - Without debug information, requiring full reverse engineering

Both challenges require bypassing PIE/ASLR to redirect execution to a `win_authed()` function while skipping a `token == 0x1337` check.

---

# **Challenge 1: PIE (Easy)**
### **Challenge Characteristics**
- **Binary:** `/challenge/binary-exploitation-pie-overflow`
- **Protections:** PIE enabled (ASLR), no stack canary
- **Given Information:**
  - Complete stack layout dump
  - Input buffer at `0x7fff1b4b6950`
  - Return address at `0x7fff1b4b6998` (72 bytes away)
  - `win_authed()` function address
  - Clear view of the check bypass point

### **Technical Analysis**
1. **PIE Behavior Understanding:**
   - Base address randomization while maintaining page alignment (0x1000)
   - Last 12 bits (3 nibbles) of addresses remain constant

2. **Stack Layout Analysis:**
   - Buffer starts at `0x7fff1b4b6950`
   - Return address at `0x7fff1b4b6998`
   - Offset calculation: `0x6998 - 0x6950 = 0x48` (72 bytes)

3. **Control Flow Hijacking:**
   - Target address after check: `0x23bb`
   - Required overwrite: Last 2 bytes (`\xbb\x23`)

### **Exploit Development**
```python
import sys
sys.stdout.buffer.write(
    b"A"*72 +           # Padding to reach return address
    b"\xbb\x23"         # Partial overwrite to jump after check
)
```

### **Execution Methodology**
- Ran exploit multiple times to account for ASLR (1/16 success probability per attempt)
- Average successful attempts: 11 for 50% confidence, 36 for 90% confidence

### **Key Learning Points**
- PIE only randomizes the base address, not offsets within pages
- Partial overwrite technique reliability
- Importance of raw byte handling in Python for exploit development

---

# **Challenge 2: PIE (Hard)**
### **Challenge Characteristics**
- **Binary:** `/challenge/binary-exploitation-pie-overflow-hard`
- **Key Differences:**
  - No debug output
  - No source code
  - Randomized buffer offsets
  - Identical PIE/ASLR mechanics but requiring full reverse engineering

### **Reverse Engineering Process**
1. **Disassembly Analysis:**
   ```bash
   objdump -d /challenge/binary-exploitation-pie-overflow-hard
   ```

2. **Critical Findings:**
   - `lea -0x70(%rbp),%rax` reveals buffer at RBP - 0x70 (112 bytes)
   - Stack frame analysis shows 8 additional bytes before return address
   - Total offset: 112 (buffer) + 8 (saved RBP) = 120 bytes

3. **Function Analysis:**
   - Located `win_authed()` at `0x1ab2`
   - Identified check at `0x1ac0` (`cmp $0x1337`)
   - Target address after check: `0x1ace`

### **Exploit Development**
```python
import sys
sys.stdout.buffer.write(
    b"A"*120 +          # Padding to reach return address
    b"\xce\x1a"         # Partial overwrite to jump after check
)
```

### **Verification Methodology**
1. **Static Analysis Verification:**
   - Confirmed stack frame layout through disassembly
   - Validated buffer location relative to return address

2. **Dynamic Analysis:**
   - Used GDB to verify stack layout during execution
   - Confirmed successful control flow redirection

### **Execution Statistics**
- Required attempts: 16-20 for reliable exploitation
- Success rate: 93.75% after 16 attempts (1 - (15/16)^16)

### **Key Technical Insights**
- Importance of understanding function prologues/epilogues
- Stack frame analysis techniques
- Reliable offset calculation methods
- Advantages of static over dynamic analysis in some scenarios

---

# **Comparative Analysis**
| Aspect                | Easy Challenge                      | Hard Challenge                        |
|-----------------------|------------------------------------|--------------------------------------|
| **Information Given** | Full debug output                  | Nothing                              |
| **Offset Discovery**  | Direct from debug info             | Reverse engineering (RBP analysis)   |
| **win_authed() Location** | Provided                         | objdump analysis                     |
| **Check Bypass**      | Clearly shown                      | Manual disassembly required          |
| **Exploit Reliability** | Higher (known addresses)         | Lower (requires brute-forcing)       |
| **Learning Value**    | Basic PIE concepts                 | Full reverse engineering skills      |

# **Conclusion**
These challenges demonstrate:
1. **Fundamental PIE bypass techniques** using partial address overwrites
2. **The importance of reverse engineering skills** when debug information is unavailable
3. **Reliable exploit development methodologies** for real-world scenarios
4. **Statistical approaches** to ASLR brute-forcing

The key technical takeaways are:
- Page alignment in PIE enables reliable partial overwrites
- Static analysis often provides more reliable information than fuzzing
- Understanding stack frames is critical for binary exploitation
- Python's `sys.stdout.buffer.write()` is essential for precise exploit delivery

This methodology applies to **any PIE-enabled binary** with a buffer overflow vulnerability, providing a reliable framework for both CTF challenges and real-world exploitation.
