[x] Opening connection to localhost on port 1337
[x] Opening connection to localhost on port 1337: Trying ::1
[x] Opening connection to localhost on port 1337: Trying 127.0.0.1
[+] Opening connection to localhost on port 1337: Done
b'The challenge() function has just been launched!\nBefore we do anything, let\'s take a look at challenge()\'s stack frame:\n+---------------------------------+-------------------------+--------------------+\n|                  Stack location |            Data (bytes) |      Data (LE int) |\n+---------------------------------+-------------------------+--------------------+\n| 0x00007ffc191954a0 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |\n| 0x00007ffc191954a8 (rsp+0x0008) | 88 66 19 19 fc 7f 00 00 | 0x00007ffc19196688 |\n| 0x00007ffc191954b0 (rsp+0x0010) | 78 66 19 19 fc 7f 00 00 | 0x00007ffc19196678 |\n| 0x00007ffc191954b8 (rsp+0x0018) | 0a 00 00 00 01 00 00 00 | 0x000000010000000a |\n| 0x00007ffc191954c0 (rsp+0x0020) | a0 56 e1 22 6d 7b 00 00 | 0x00007b6d22e156a0 |\n| 0x00007ffc191954c8 (rsp+0x0028) | b8 6a 36 1e d3 61 00 00 | 0x000061d31e366ab8 |\n| 0x00007ffc191954d0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc191954d8 (rsp+0x0038) | e0 54 19 19 fc 7f 00 00 | 0x00007ffc191954e0 |\n| 0x00007ffc191954e0 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc191954e8 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc191954f0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc191954f8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc19195500 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc19195508 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc19195510 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc19195518 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |\n| 0x00007ffc19195520 (rsp+0x0080) | 00 00 00 00 00 7f 00 00 | 0x00007f0000000000 |\n| 0x00007ffc19195528 (rsp+0x0088) | 00 94 da ea d7 88 20 f8 | 0xf82088d7eada9400 |\n| 0x00007ffc19195530 (rsp+0x0090) | 80 65 19 19 fc 7f 00 00 | 0x00007ffc19196580 |\n| 0x00007ffc19195538 (rsp+0x0098) | db 48 36 1e d3 61 00 00 | 0x000061d31e3648db |\n+---------------------------------+-------------------------+--------------------+\nOur stack pointer points to 0x7ffc191954a0, and our base pointer points to 0x7ffc19195530.\nThis means that we have (decimal) 20 8-byte words in our stack frame,\nincluding the saved base pointer and the saved return address, for a\ntotal of 160 bytes.\nThe input buffer begins at 0x7ffc191954e0, partway through the stack frame,\n("above" it in the stack are other local variables used by the function).\nYour input will be read into this buffer.\nThe buffer is 69 bytes long, but the program will let you provide an arbitrarily\nlarge input length, and thus overflow the buffer.\n\nIn this level, there is no "win" variable.\nYou will need to force the program to execute the win_authed() function\nby directly overflowing into the stored return address back to main,\nwhich is stored at 0x7ffc19195538, 88 bytes after the start of your input buffer.\nThat means that you will need to input at least 96 bytes (69 to fill the buffer,\n19 to fill other stuff stored between the buffer and the return address,\nand 8 that will overwrite the return address).\n\nWhile canaries are enabled, this networked program forks.\nWhat is important to note is that the canary does not get re-randomized on fork.\n\nWhen data that you are overflowing into is critical (i.e., if you screw it up\nthe program crashes), but also static across executions, you can brute-force\nit byte by byte over many attempts.\n\nSo, let\'s brute-force the canary!\nIf this is your first time running this program, all you know so far is that\nthe canary has a 0 as its left-most byte.\nYou should proceed like this:\n\n- First, you should try overflowing just the null byte of the canary, for\n  practice. The canary starts at 0x7ffc19195528, which is 72 bytes after the\n  start of your buffer. Thus, you should provide 72 characters followed\n  by a NULL byte, make sure the canary check passes, then try a non-NULL\n  byte and make sure the canary check fails. This will confirm the offsets.\n- Next try each possible value for just the next byte. One of them (the same\n  as whatever was there in memory already) will keep the canary intact, and\n  when the canary check succeeds, you know you have found the correct one.\n- Go on to the next byte, leak it the same way, and so on, until you have\n  the whole canary.\n\nYou will likely want to script this process! Each byte might take up to 256\ntries to guess..\n\nBecause the binary is position independent, you cannot know\nexactly where the win_authed() function is located.\nThis means that it is not clear what should be written into the return address.\n\nPayload size:'
b' You have chosen to send 80 bytes of input!\nThis will allow you to write from 0x7ffc191954e0 (the start of the input buffer)\nright up to (but not including) 0x7ffc19195530 (which is 11 bytes beyond the end of the buffer).\nOf these, you will overwrite -8 bytes into the return address.\nIf that number is greater than 8, you will overwrite the entire return address.\n\nOverwriting the entire return address is fine when we know\nthe whole address, but here, we only really know the last three nibbles.\nThese nibbles never change, because pages are aligned to 0x1000.\nThis gives us a workaround: we can overwrite the least significant byte\nof the saved return address, which we can know from debugging the binary,\nto retarget the return to main to any instruction that shares the other 7 bytes.\nSince that last byte will be constant between executions (due to page alignment),\nthis will always work.\nIf the address we want to redirect execution to is a bit farther away from\nthe saved return address, and we need to write two bytes, then one of those\nnibbles (the fourth least-significant one) will be a guess, and it will be\nincorrect 15 of 16 times.\nThis is okay: we can just run our exploit a few times until it works\n(statistically, ~50% chance after 11 times and ~90% chance after 36 times).\nOne caveat in this challenge is that the win_authed() function must first auth:\nit only lets you win if you provide it with the argument 0x1337.\nSpeifically, the win_authed() function looks something like:\n    void win_authed(int token)\n    {\n      if (token != 0x1337) return;\n      puts("You win! Here is your flag: ");\n      sendfile(1, open("/flag", 0), 0, 256);\n      puts("");\n    }\n\nSo how do you pass the check? There *is* a way, and we will cover it later,\nbut for now, we will simply bypass it! You can overwrite the return address\nwith *any* value (as long as it points to executable code), not just the start\nof functions. Let\'s overwrite past the token check in win!\n\nTo do this, we will need to analyze the program with objdump, identify where\nthe check is in the win_authed() function, find the address right after the check,\nand write that address over the saved return address.\n\nGo ahead and find this address now. When you\'re ready, input a buffer overflow\nthat will overwrite the saved return address (at 0x7ffc19195538, 88 bytes into the buffer)\nwith the correct value.\n\nSend your payload'
[*] Switching to interactive mode
 (up to 80 bytes)!
You sent 80 bytes!
[*] Got EOF while reading in interactive
[*] Interrupted
[*] Closed connection to localhost port 1337
